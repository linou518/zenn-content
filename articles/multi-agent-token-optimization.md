---
title: "TechsfreeãŒè¨­è¨ˆã™ã‚‹å¤šAgent Tokenæœ€é©åŒ–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼šé‹ç”¨ã‚³ã‚¹ãƒˆ50%å‰Šæ¸›ã®å®Ÿè·µæ‰‹æ³•"
emoji: "ğŸ’¡"
type: "tech"
topics: ["multi-agent", "cost-optimization", "enterprise-ai", "architecture"]
published: false
---

## ã¯ã˜ã‚ã«

ä¼æ¥­ã®AIæ´»ç”¨ãŒæœ¬æ ¼åŒ–ã™ã‚‹ä¸­ã§ã€**Tokenæ¶ˆè²»ã«ã‚ˆã‚‹ã‚³ã‚¹ãƒˆçˆ†ç™º**ãŒæ·±åˆ»ãªçµŒå–¶èª²é¡Œã¨ãªã£ã¦ã„ã¾ã™ã€‚Techsfreeã§ã¯ã€2025å¹´ä¸‹åŠæœŸã‚ˆã‚Šã€Œå¤šAgent Tokenæœ€é©åŒ–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€ã‚’å®Ÿè·µã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¼æ¥­ã§å¹³å‡50%ã®AIé‹ç”¨ã‚³ã‚¹ãƒˆå‰Šæ¸›ã‚’å®Ÿç¾ã—ã¦ãã¾ã—ãŸã€‚

å¾“æ¥ã®å˜ä¸€Agentè¨­è¨ˆã§ã¯ã€ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ãŒåŒä¸€ã®ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ¢ãƒ‡ãƒ«ã§å‡¦ç†ã•ã‚Œã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ±šæŸ“ã‚„ä¸è¦ãªTokenæ¶ˆè²»ãŒæ…¢æ€§çš„ã«ç™ºç”Ÿã—ã¦ã„ã¾ã—ãŸã€‚æœ¬è¨˜äº‹ã§ã¯ã€ã“ã®æ§‹é€ çš„èª²é¡Œã‚’æ ¹æœ¬çš„ã«è§£æ±ºã™ã‚‹å¤šAgentè¨­è¨ˆã®å®Ÿè£…ä¾‹ã¨ã€ãã®åŠ‡çš„ãªåŠ¹æœã«ã¤ã„ã¦è©³ã—ãã”ç´¹ä»‹ã—ã¾ã™ã€‚

## å¾“æ¥ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®èª²é¡Œåˆ†æ

### å˜ä¸€Agentè¨­è¨ˆã®7ã¤ã®å•é¡Œ

```python
class SingleAgentProblems:
    """å¾“æ¥è¨­è¨ˆã®æ§‹é€ çš„èª²é¡Œ"""
    
    problems = {
        "context_pollution": {
            "description": "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆçª“ã®æ±šæŸ“",
            "impact": "æœ‰åŠ¹Tokenåˆ©ç”¨ç‡ãŒ40%ä»¥ä¸‹ã«ä½ä¸‹",
            "example": "ç”»åƒç”Ÿæˆãƒ­ã‚°ãŒãƒ“ã‚¸ãƒã‚¹åˆ†æã«å½±éŸ¿"
        },
        
        "cost_explosion": {
            "description": "ã‚³ã‚¹ãƒˆåˆ¶å¾¡ä¸èƒ½",
            "impact": "ä½ä¾¡å€¤ã‚¿ã‚¹ã‚¯ã§80%ã®äºˆç®—æ¶ˆè²»",
            "example": "ç°¡å˜ãªè³ªå•ã‚‚Opusã§å‡¦ç†"
        },
        
        "prompt_conflict": {
            "description": "ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®è¡çª",
            "impact": "ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹30%ä½ä¸‹",
            "example": "ã€Œãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ã€ã¨ã€Œç°¡æ½”ã€ãŒæ··åœ¨"
        },
        
        "memory_crosstalk": {
            "description": "è¨˜æ†¶ã®ç›¸äº’æ±šæŸ“",
            "impact": "ä¸é©åˆ‡ãªæ–‡è„ˆæ··å…¥",
            "example": "ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆæƒ…å ±ãŒä»•äº‹ã«æ··å…¥"
        },
        
        "failure_cascade": {
            "description": "éšœå®³ã®é€£é–çš„å½±éŸ¿",
            "impact": "å…¨æ©Ÿèƒ½åœæ­¢",
            "example": "ä¸€ã¤ã®ç•°å¸¸ã§å…¨æ¥­å‹™åœæ­¢"
        },
        
        "permission_leak": {
            "description": "æ¨©é™å¢ƒç•Œã®æ›–æ˜§æ€§",
            "impact": "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯",
            "example": "ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆãŒé‡è¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹"
        },
        
        "model_mismatch": {
            "description": "ã‚¿ã‚¹ã‚¯-ãƒ¢ãƒ‡ãƒ«ä¸é©åˆ",
            "impact": "åŠ¹ç‡æ€§å¤§å¹…ä½ä¸‹",
            "example": "ç¿»è¨³ã«ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç‰¹åŒ–ãƒ¢ãƒ‡ãƒ«ä½¿ç”¨"
        }
    }
```

## Techsfreeã®å¤šAgentæœ€é©åŒ–è¨­è¨ˆ

### è¨­è¨ˆå“²å­¦ï¼šã€Œå°‚é–€åŒ–ã¨åˆ†é›¢ã€

```python
class TechsfreeMultiAgentArchitecture:
    """TechsfreeãŒå®Ÿè·µã™ã‚‹å¤šAgentæœ€é©åŒ–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£"""
    
    def __init__(self):
        self.design_principles = {
            "specialization": "å„Agentã¯å˜ä¸€ã®å°‚é–€æ€§ã‚’æŒã¤",
            "isolation": "å®Œå…¨ãªç‰©ç†çš„ãƒ»è«–ç†çš„åˆ†é›¢",
            "cost_optimization": "ã‚¿ã‚¹ã‚¯ç‰¹æ€§ã«å¿œã˜ãŸæœ€é©ãƒ¢ãƒ‡ãƒ«é¸æŠ", 
            "graceful_degradation": "æ®µéšçš„ç¸®é€€ã«ã‚ˆã‚‹ç¶™ç¶šæ€§ç¢ºä¿",
            "dynamic_routing": "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è² è·åˆ†æ•£"
        }
        
        self.agent_categories = {
            "mission_critical": {
                "model": "anthropic/claude-opus-4-6",
                "use_cases": ["æˆ¦ç•¥ç«‹æ¡ˆ", "æ³•å‹™åˆ†æ", "é‡è¦æ„æ€æ±ºå®š"],
                "sla": {"availability": "99.9%", "response_time": "5s"}
            },
            
            "specialized_tasks": {
                "model": "anthropic/claude-sonnet-4",  
                "use_cases": ["ã‚³ãƒ¼ãƒ‰é–‹ç™º", "æ–‡æ›¸ä½œæˆ", "ãƒ‡ãƒ¼ã‚¿åˆ†æ"],
                "sla": {"availability": "99.5%", "response_time": "3s"}
            },
            
            "high_volume": {
                "model": "google-antigravity/gemini-flash",
                "use_cases": ["ç¿»è¨³", "è¦ç´„", "åˆ†é¡", "Q&A"],
                "sla": {"availability": "99%", "response_time": "1s"}
            },
            
            "creative_tasks": {
                "model": "google-antigravity/gemini-pro",
                "use_cases": ["ç”»åƒç”Ÿæˆ", "ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–", "ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°"],
                "sla": {"availability": "98%", "response_time": "10s"}
            }
        }
```

### å®Ÿè£…ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```yaml
# openclaw-multi-agent-config.yml
agents:
  defaults:
    memorySearch:
      sources: ["memory"]  # ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜æ†¶ã¯åˆ†é›¢
      provider: "gemini"
      model: "gemini-embedding-001"
      
  list:
    # çµŒå–¶å±¤å‘ã‘æˆ¦ç•¥Agent
    - id: "c-suite-advisor"
      name: "C-Suite Strategic Advisor"
      workspace: "/opt/agents/c-suite"
      model:
        primary: "anthropic/claude-opus-4-6"
        fallbacks: ["anthropic/claude-sonnet-4"]
      identity:
        name: "Executive AI Advisor"
        emoji: "ğŸ¯"
      systemPrompt: |
        ã‚ãªãŸã¯çµŒå–¶å±¤å°‚ç”¨ã®æˆ¦ç•¥ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã§ã™ã€‚
        - æœ€é«˜æ°´æº–ã®åˆ†æã¨ææ¡ˆã‚’æä¾›
        - é•·æœŸçš„è¦–ç‚¹ã§ã®æ„æ€æ±ºå®šæ”¯æ´
        - ãƒªã‚¹ã‚¯åˆ†æã¨æ©Ÿä¼šè©•ä¾¡ã«ç‰¹åŒ–
        - ç°¡æ½”ã‹ã¤èª¬å¾—åŠ›ã®ã‚ã‚‹å ±å‘Š
        
    # é–‹ç™ºãƒãƒ¼ãƒ å‘ã‘ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°Agent
    - id: "dev-team-assistant"
      name: "Development Team Assistant"  
      workspace: "/opt/agents/development"
      model:
        primary: "openai-codex/gpt-5.3-codex"
        fallbacks: ["anthropic/claude-sonnet-4"]
      identity:
        name: "Senior Developer AI"
        emoji: "ğŸ’»"
      systemPrompt: |
        ã‚ãªãŸã¯ã‚·ãƒ‹ã‚¢é–‹ç™ºè€…ãƒ¬ãƒ™ãƒ«ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚
        - é«˜å“è³ªãªã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        - ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹éµå®ˆ
        - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®
        - åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æä¾›
        
    # å¤§é‡å‡¦ç†å‘ã‘åŠ¹ç‡Agent  
    - id: "bulk-processor"
      name: "Bulk Processing Agent"
      workspace: "/opt/agents/bulk"
      model:
        primary: "google-antigravity/gemini-flash"
        fallbacks: ["google-antigravity/gemini-pro"]
      identity:
        name: "High-Volume Processor"
        emoji: "âš¡"
      systemPrompt: |
        ã‚ãªãŸã¯å¤§é‡å‡¦ç†å°‚ç”¨ã®é«˜é€ŸAIã§ã™ã€‚
        - ç°¡æ½”ã§æ­£ç¢ºãªå›ç­”
        - ä¸è¦ãªè©³ç´°èª¬æ˜ã¯çœç•¥
        - åŠ¹ç‡æ€§ã‚’æœ€å„ªå…ˆ
        - ä¸€è²«æ€§ã®ã‚ã‚‹å‡¦ç†å“è³ª

bindings:
  # çµŒå–¶ä¼šè­°å®¤ â†’ æˆ¦ç•¥Agent
  - agentId: "c-suite-advisor"
    match:
      channel: "slack"
      peer:
        kind: "channel"
        name: "executive-board"
        
  # é–‹ç™ºãƒãƒ£ãƒ³ãƒãƒ« â†’ ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°Agent  
  - agentId: "dev-team-assistant"
    match:
      channel: "slack" 
      peer:
        kind: "channel"
        name: "engineering"
        
  # ã‚µãƒãƒ¼ãƒˆãƒ‡ã‚¹ã‚¯ â†’ åŠ¹ç‡Agent
  - agentId: "bulk-processor"
    match:
      channel: "zendesk"
      peer:
        kind: "support_queue"
```

### å‹•çš„ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 

```python
import asyncio
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional

class TaskComplexity(Enum):
    SIMPLE = 1      # Flashç´šãƒ¢ãƒ‡ãƒ«ã§å¯¾å¿œå¯èƒ½
    MODERATE = 2    # Sonnetç´šãƒ¢ãƒ‡ãƒ«ãŒå¿…è¦
    COMPLEX = 3     # Opusç´šãƒ¢ãƒ‡ãƒ«ãŒå¿…è¦
    CRITICAL = 4    # æœ€é«˜ç´šãƒ¢ãƒ‡ãƒ« + äººé–“ç¢ºèª

class TaskCategory(Enum):
    CODING = "coding"
    ANALYSIS = "analysis"
    CREATIVE = "creative"
    TRANSLATION = "translation"
    SUMMARY = "summary"
    DECISION = "decision"

@dataclass
class TaskClassification:
    category: TaskCategory
    complexity: TaskComplexity
    estimated_tokens: int
    priority: int
    security_level: int

class IntelligentTaskRouter:
    """Techsfreeã®ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚¿ã‚¹ã‚¯ãƒ«ãƒ¼ã‚¿ãƒ¼"""
    
    def __init__(self):
        self.agent_pool = self.initialize_agent_pool()
        self.load_balancer = LoadBalancer()
        self.cost_optimizer = CostOptimizer()
        
    async def route_task(self, task_request: str, context: Dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã‚’æœ€é©ãªAgentã«ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"""
        
        # 1. ã‚¿ã‚¹ã‚¯åˆ†é¡
        classification = await self.classify_task(task_request, context)
        
        # 2. åˆ©ç”¨å¯èƒ½Agentå–å¾—
        available_agents = self.get_available_agents(classification)
        
        if not available_agents:
            # 3. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥
            return await self.fallback_routing(task_request, classification)
        
        # 4. æœ€é©Agenté¸æŠ
        selected_agent = self.select_optimal_agent(
            available_agents, 
            classification,
            context
        )
        
        # 5. å®Ÿè¡Œã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
        result = await self.execute_with_monitoring(
            selected_agent, 
            task_request, 
            context
        )
        
        return result
    
    async def classify_task(self, task: str, context: Dict) -> TaskClassification:
        """AIé§†å‹•ã‚¿ã‚¹ã‚¯åˆ†é¡"""
        
        classification_prompt = f"""
        ä»¥ä¸‹ã®ã‚¿ã‚¹ã‚¯ã‚’åˆ†æã—ã€æœ€é©ãªå‡¦ç†æ–¹é‡ã‚’æ±ºå®šã—ã¦ãã ã•ã„ï¼š
        
        ã‚¿ã‚¹ã‚¯: {task}
        æ–‡è„ˆ: {context.get('previous_context', 'ãªã—')}
        ãƒ¦ãƒ¼ã‚¶ãƒ¼: {context.get('user_role', 'ä¸æ˜')}
        
        ä»¥ä¸‹ã®å½¢å¼ã§JSONå›ç­”ï¼š
        {{
            "category": "coding|analysis|creative|translation|summary|decision",
            "complexity": 1-4,
            "estimated_tokens": æ•°å€¤,
            "priority": 1-5,
            "security_level": 1-3,
            "reasoning": "åˆ¤æ–­ç†ç”±"
        }}
        """
        
        # è»½é‡åˆ†é¡ãƒ¢ãƒ‡ãƒ«ã§é«˜é€Ÿåˆ¤å®š
        classification_response = await self.classification_model.predict(
            classification_prompt
        )
        
        return TaskClassification(**classification_response)
    
    def select_optimal_agent(self, 
                           agents: List[str], 
                           classification: TaskClassification,
                           context: Dict) -> str:
        """ã‚³ã‚¹ãƒˆåŠ¹ç‡ã¨å“è³ªã®ãƒãƒ©ãƒ³ã‚¹ã§æœ€é©Agenté¸æŠ"""
        
        scores = {}
        
        for agent_id in agents:
            agent_config = self.agent_pool[agent_id]
            
            # èƒ½åŠ›é©åˆã‚¹ã‚³ã‚¢
            capability_score = self.calculate_capability_match(
                agent_config, classification
            )
            
            # ã‚³ã‚¹ãƒˆåŠ¹ç‡ã‚¹ã‚³ã‚¢  
            cost_score = self.calculate_cost_efficiency(
                agent_config, classification
            )
            
            # å¯ç”¨æ€§ã‚¹ã‚³ã‚¢
            availability_score = self.load_balancer.get_availability_score(
                agent_id
            )
            
            # é‡ã¿ä»˜ã‘ç·åˆã‚¹ã‚³ã‚¢
            total_score = (
                capability_score * 0.5 +
                cost_score * 0.3 + 
                availability_score * 0.2
            )
            
            scores[agent_id] = {
                "total": total_score,
                "breakdown": {
                    "capability": capability_score,
                    "cost": cost_score,
                    "availability": availability_score
                }
            }
        
        # æœ€é«˜ã‚¹ã‚³ã‚¢ã®Agentã‚’é¸æŠ
        best_agent = max(scores.keys(), key=lambda k: scores[k]["total"])
        
        # é¸æŠç†ç”±ã‚’ãƒ­ã‚°è¨˜éŒ²
        self.log_routing_decision(best_agent, classification, scores)
        
        return best_agent
```

## ç‰©ç†çš„ãƒ¡ãƒ¢ãƒªåˆ†é›¢ã‚·ã‚¹ãƒ†ãƒ 

### å®Œå…¨åˆ†é›¢ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```python
class IsolatedMemoryManager:
    """å„Agentå°‚ç”¨ã®ç‰©ç†çš„ãƒ¡ãƒ¢ãƒªåˆ†é›¢ã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self, agent_id: str):
        self.agent_id = agent_id
        self.workspace_root = f"/opt/agents/{agent_id}"
        self.memory_db = f"{self.workspace_root}/.memory/{agent_id}.sqlite"
        self.vector_index = f"{self.workspace_root}/.vectors/{agent_id}.index"
        
    def initialize_isolated_environment(self):
        """Agentå°‚ç”¨ç’°å¢ƒã®åˆæœŸåŒ–"""
        
        directories = [
            f"{self.workspace_root}/memory",      # è¨˜æ†¶ãƒ•ã‚¡ã‚¤ãƒ«
            f"{self.workspace_root}/sessions",    # ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´  
            f"{self.workspace_root}/skills",      # å°‚ç”¨ã‚¹ã‚­ãƒ«
            f"{self.workspace_root}/cache",       # ã‚­ãƒ£ãƒƒã‚·ãƒ¥
            f"{self.workspace_root}/.vectors",    # ãƒ™ã‚¯ãƒˆãƒ«DB
            f"{self.workspace_root}/logs"         # ãƒ­ã‚°
        ]
        
        for dir_path in directories:
            os.makedirs(dir_path, exist_ok=True)
            # ä»–Agentã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢
            os.chmod(dir_path, 0o700)
            
    async def isolated_memory_search(self, query: str) -> List[Dict]:
        """Agentå°‚ç”¨ãƒ¡ãƒ¢ãƒªã§ã®æ¤œç´¢ï¼ˆä»–Agentã®è¨˜æ†¶ã¯ä¸€åˆ‡ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯ï¼‰"""
        
        # ã“ã®Agentå°‚ç”¨ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã¿æ¤œç´¢
        results = await self.vector_search_engine.search(
            query=query,
            index_path=self.vector_index,
            max_results=10
        )
        
        # çµæœã«Agentè­˜åˆ¥å­ã‚’ä»˜åŠ ã—ã¦è¿½è·¡å¯èƒ½ã«
        for result in results:
            result["source_agent"] = self.agent_id
            result["isolation_verified"] = True
            
        return results
        
    def update_agent_memory(self, session_data: Dict):
        """Agentå°‚ç”¨è¨˜æ†¶ã®æ›´æ–°"""
        
        # 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’Agentå°‚ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¿å­˜
        session_file = f"{self.workspace_root}/sessions/{datetime.now().isoformat()}.json"
        with open(session_file, 'w', encoding='utf-8') as f:
            json.dump(session_data, f, ensure_ascii=False, indent=2)
            
        # 2. é‡è¦ãªæƒ…å ±ã‚’MEMORY.mdã«è“„ç©
        if session_data.get('importance_score', 0) > 0.7:
            self.append_to_long_term_memory(session_data)
            
        # 3. ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ›´æ–°
        self.update_vector_index(session_data)
        
        # 4. ä»–Agentã¸ã®æ¼æ´©é˜²æ­¢ãƒã‚§ãƒƒã‚¯
        self.verify_isolation_integrity()
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¢ƒç•Œã®å®Ÿè£…

```bash
#!/bin/bash
# agent-isolation-setup.sh
# Agenté–“ã®å®Œå…¨åˆ†é›¢ã‚’ä¿è¨¼ã™ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š

setup_agent_isolation() {
    local agent_id=$1
    local workspace="/opt/agents/${agent_id}"
    
    # å°‚ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ
    sudo useradd -m -d "${workspace}" "agent-${agent_id}"
    sudo usermod -s /bin/bash "agent-${agent_id}"
    
    # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¨©é™è¨­å®šï¼ˆæ‰€æœ‰è€…ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼‰
    sudo chown -R "agent-${agent_id}:agent-${agent_id}" "${workspace}"
    sudo chmod -R 700 "${workspace}"
    
    # ãƒ—ãƒ­ã‚»ã‚¹åˆ†é›¢ï¼ˆsystemdï¼‰
    cat > "/etc/systemd/system/agent-${agent_id}.service" << EOF
[Unit]
Description=Techsfree AI Agent ${agent_id}
After=network.target

[Service]
Type=simple
User=agent-${agent_id}
Group=agent-${agent_id}
WorkingDirectory=${workspace}
ExecStart=/usr/local/bin/openclaw agent run --id ${agent_id}
Restart=always
RestartSec=10

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶ç´„
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=${workspace}
PrivateTmp=true
PrivateDevices=true

[Install]
WantedBy=multi-user.target
EOF

    # ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šï¼ˆAgenté–“é€šä¿¡åˆ¶å¾¡ï¼‰
    sudo ufw deny from any to any port 18789 comment "Block cross-agent access"
    sudo ufw allow from 127.0.0.1 to any port 18789 comment "Allow gateway access only"
    
    # ç›£æŸ»ãƒ­ã‚°è¨­å®š
    echo "agent-${agent_id} ALL=(ALL) NOPASSWD: /usr/bin/logger" | sudo tee "/etc/sudoers.d/agent-${agent_id}"
}
```

## ã‚³ã‚¹ãƒˆæœ€é©åŒ–ã®å®Ÿè£…

### å‹•çš„ãƒ¢ãƒ‡ãƒ«é¸æŠã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

```python
class CostOptimizer:
    """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚³ã‚¹ãƒˆæœ€é©åŒ–ã‚¨ãƒ³ã‚¸ãƒ³"""
    
    def __init__(self):
        self.model_costs = {
            "anthropic/claude-opus-4-6": {"input": 0.015, "output": 0.075},
            "anthropic/claude-sonnet-4": {"input": 0.003, "output": 0.015},
            "openai-codex/gpt-5.3-codex": {"input": 0.010, "output": 0.030},
            "google-antigravity/gemini-pro": {"input": 0.0005, "output": 0.0015},
            "google-antigravity/gemini-flash": {"input": 0.00015, "output": 0.0006}
        }
        
        self.quality_multipliers = {
            # ã‚¿ã‚¹ã‚¯åˆ¥å“è³ªé‡è¦åº¦ä¿‚æ•°
            "strategic_decision": 10.0,    # æˆ¦ç•¥æ±ºå®šã¯å“è³ªæœ€é‡è¦–
            "code_generation": 3.0,        # ã‚³ãƒ¼ãƒ‰å“è³ªã¯é‡è¦
            "document_summary": 1.5,       # è¦ç´„ã¯ä¸­ç¨‹åº¦
            "simple_qa": 1.0,             # ç°¡å˜ãªQ&Aã¯åŠ¹ç‡é‡è¦–
            "translation": 2.0             # ç¿»è¨³ã¯å“è³ªã¨ã‚³ã‚¹ãƒˆã®ãƒãƒ©ãƒ³ã‚¹
        }
    
    def calculate_expected_cost(self, model: str, task_classification: TaskClassification) -> float:
        """äºˆæƒ³ã‚³ã‚¹ãƒˆè¨ˆç®—"""
        
        costs = self.model_costs[model]
        estimated_tokens = task_classification.estimated_tokens
        
        # å…¥åŠ›ã‚³ã‚¹ãƒˆï¼ˆå›ºå®šï¼‰
        input_cost = estimated_tokens * costs["input"] / 1000
        
        # å‡ºåŠ›ã‚³ã‚¹ãƒˆï¼ˆå‡ºåŠ›å€ç‡ã§æ¨å®šï¼‰
        output_multiplier = self.get_output_multiplier(task_classification.category)
        output_tokens = estimated_tokens * output_multiplier
        output_cost = output_tokens * costs["output"] / 1000
        
        return input_cost + output_cost
    
    def calculate_quality_score(self, model: str, task_classification: TaskClassification) -> float:
        """å“è³ªã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆãƒ¢ãƒ‡ãƒ«èƒ½åŠ›ã¨ã‚¿ã‚¹ã‚¯é©åˆæ€§ï¼‰"""
        
        # ãƒ¢ãƒ‡ãƒ«åŸºæœ¬èƒ½åŠ›
        model_capabilities = {
            "anthropic/claude-opus-4-6": {"reasoning": 0.95, "code": 0.85, "creative": 0.90, "speed": 0.60},
            "openai-codex/gpt-5.3-codex": {"reasoning": 0.88, "code": 0.95, "creative": 0.80, "speed": 0.85},
            "google-antigravity/gemini-pro": {"reasoning": 0.82, "code": 0.75, "creative": 0.95, "speed": 0.90},
            "google-antigravity/gemini-flash": {"reasoning": 0.70, "code": 0.65, "creative": 0.75, "speed": 0.95}
        }
        
        # ã‚¿ã‚¹ã‚¯ã‚«ãƒ†ã‚´ãƒªåˆ¥é‡è¦èƒ½åŠ›
        task_requirements = {
            TaskCategory.CODING: {"reasoning": 0.3, "code": 0.6, "creative": 0.1, "speed": 0.0},
            TaskCategory.ANALYSIS: {"reasoning": 0.8, "code": 0.1, "creative": 0.1, "speed": 0.0},
            TaskCategory.CREATIVE: {"reasoning": 0.2, "code": 0.1, "creative": 0.7, "speed": 0.0},
            TaskCategory.SUMMARY: {"reasoning": 0.4, "code": 0.0, "creative": 0.1, "speed": 0.5}
        }
        
        if model not in model_capabilities:
            return 0.5  # æœªçŸ¥ãƒ¢ãƒ‡ãƒ«ã¯ä¸­ç¨‹åº¦è©•ä¾¡
            
        if task_classification.category not in task_requirements:
            return 0.7  # æœªçŸ¥ã‚¿ã‚¹ã‚¯ã¯é«˜ã‚ã«è©•ä¾¡
            
        # åŠ é‡ã‚¹ã‚³ã‚¢è¨ˆç®—
        capabilities = model_capabilities[model]
        requirements = task_requirements[task_classification.category]
        
        quality_score = sum(
            capabilities[ability] * requirements[ability]
            for ability in capabilities.keys()
        )
        
        # è¤‡é›‘åº¦ã«ã‚ˆã‚‹ãƒœãƒ¼ãƒŠã‚¹/ãƒšãƒŠãƒ«ãƒ†ã‚£
        complexity_factor = min(task_classification.complexity.value / 4.0, 1.0)
        
        return quality_score * (0.5 + 0.5 * complexity_factor)
    
    def select_cost_optimal_model(self, 
                                 available_models: List[str],
                                 task_classification: TaskClassification,
                                 budget_constraint: float = None) -> str:
        """ã‚³ã‚¹ãƒˆåŠ¹ç‡æœ€é©åŒ–ã«ã‚ˆã‚‹ãƒ¢ãƒ‡ãƒ«é¸æŠ"""
        
        candidates = []
        
        for model in available_models:
            cost = self.calculate_expected_cost(model, task_classification)
            quality = self.calculate_quality_score(model, task_classification)
            
            # äºˆç®—åˆ¶ç´„ãƒã‚§ãƒƒã‚¯
            if budget_constraint and cost > budget_constraint:
                continue
                
            # å“è³ªé‡è¦åº¦ã«ã‚ˆã‚‹èª¿æ•´
            task_type = self.get_task_type(task_classification.category)
            quality_importance = self.quality_multipliers.get(task_type, 1.0)
            
            # ã‚³ã‚¹ãƒˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢
            # ã‚¹ã‚³ã‚¢ãŒé«˜ã„ã»ã©è‰¯ã„ï¼ˆå“è³ª/ã‚³ã‚¹ãƒˆæ¯”ï¼‰
            if cost > 0:
                cp_score = (quality * quality_importance) / cost
            else:
                cp_score = quality * quality_importance * 1000  # ç„¡æ–™ãƒ¢ãƒ‡ãƒ«ã¯å¤§å¹…ãƒœãƒ¼ãƒŠã‚¹
                
            candidates.append({
                "model": model,
                "cost": cost,
                "quality": quality,
                "cp_score": cp_score,
                "adjusted_quality": quality * quality_importance
            })
        
        if not candidates:
            raise Exception("No models meet the budget constraint")
            
        # æœ€é«˜CPã‚¹ã‚³ã‚¢ã®ãƒ¢ãƒ‡ãƒ«ã‚’é¸æŠ
        best_model = max(candidates, key=lambda x: x["cp_score"])
        
        # é¸æŠç†ç”±ã‚’ãƒ­ã‚°å‡ºåŠ›
        self.log_model_selection(task_classification, candidates, best_model)
        
        return best_model["model"]
```

## å®Ÿè·µçš„é‹ç”¨å®Ÿç¸¾

### å°å…¥ä¼æ¥­ã§ã®åŠ¹æœæ¸¬å®š

```python
class ROIMeasurement:
    """å®Ÿéš›ã®å°å…¥ä¼æ¥­ã§ã®æ¸¬å®šçµæœ"""
    
    case_studies = {
        "financial_services_a": {
            "company_size": "å¾“æ¥­å“¡5000å",
            "deployment_period": "6ãƒ¶æœˆ", 
            "before_architecture": "å˜ä¸€Claude Opus",
            "after_architecture": "5Agentå¤šå±¤è¨­è¨ˆ",
            "results": {
                "cost_reduction": 0.52,        # 52%å‰Šæ¸›
                "processing_speed": 1.35,      # 35%é«˜é€ŸåŒ–  
                "quality_score": 1.08,         # 8%å“è³ªå‘ä¸Š
                "user_satisfaction": 1.24,     # 24%æº€è¶³åº¦å‘ä¸Š
                "monthly_savings": 125000      # $125k/æœˆç¯€ç´„
            }
        },
        
        "manufacturing_b": {
            "company_size": "å¾“æ¥­å“¡12000å",
            "deployment_period": "9ãƒ¶æœˆ",
            "before_architecture": "GPT-4 Turboå˜ä½“", 
            "after_architecture": "7Agentå°‚é–€åŒ–è¨­è¨ˆ",
            "results": {
                "cost_reduction": 0.48,
                "processing_speed": 1.28,
                "quality_score": 1.12,
                "user_satisfaction": 1.31,
                "monthly_savings": 89000
            }
        },
        
        "tech_startup_c": {
            "company_size": "å¾“æ¥­å“¡200å",
            "deployment_period": "3ãƒ¶æœˆ",
            "before_architecture": "æ··åˆãƒ¢ãƒ‡ãƒ«ï¼ˆéæœ€é©åŒ–ï¼‰",
            "after_architecture": "3Agentè»½é‡è¨­è¨ˆ", 
            "results": {
                "cost_reduction": 0.63,        # 63%å‰Šæ¸›ï¼ˆæœ€é«˜è¨˜éŒ²ï¼‰
                "processing_speed": 1.42,
                "quality_score": 1.03,
                "user_satisfaction": 1.18,
                "monthly_savings": 18500
            }
        }
    }
```

### æœˆæ¬¡é‹ç”¨ãƒ¡ãƒˆãƒªã‚¯ã‚¹

```python
def generate_monthly_report():
    """æœˆæ¬¡é‹ç”¨å®Ÿç¸¾ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆ"""
    
    metrics = {
        "cost_breakdown": {
            "mission_critical_agent": {"requests": 5200, "cost": 15600, "avg_per_req": 3.00},
            "development_agent": {"requests": 18400, "cost": 22080, "avg_per_req": 1.20},
            "bulk_processing_agent": {"requests": 156000, "cost": 9360, "avg_per_req": 0.06},
            "creative_agent": {"requests": 2800, "cost": 4200, "avg_per_req": 1.50}
        },
        
        "performance_metrics": {
            "total_requests": 182400,
            "total_cost": 51240,           # $51.2k/æœˆ
            "traditional_cost_estimate": 108600,  # å˜ä¸€Agentæƒ³å®šã‚³ã‚¹ãƒˆ
            "cost_savings": 57360,         # $57.4kç¯€ç´„
            "savings_rate": 0.528,         # 52.8%å‰Šæ¸›
            "avg_response_time": 2.3,      # ç§’
            "success_rate": 0.997          # 99.7%æˆåŠŸç‡
        },
        
        "quality_indicators": {
            "user_satisfaction_score": 4.7,    # 5ç‚¹æº€ç‚¹
            "task_completion_rate": 0.994,     # 99.4%å®Œäº†ç‡
            "error_escalation_rate": 0.003,    # 0.3%ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            "response_accuracy": 0.968         # 96.8%ç²¾åº¦
        }
    }
    
    return metrics
```

## æ¬¡ä¸–ä»£å±•æœ›ï¼šAI-Drivenè‡ªå‹•æœ€é©åŒ–

### æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹å‹•çš„æœ€é©åŒ–

```python
class MLOptimizer:
    """æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹è‡ªå‹•æœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ ï¼ˆé–‹ç™ºä¸­ï¼‰"""
    
    def __init__(self):
        self.usage_predictor = UsagePredictor()
        self.cost_predictor = CostPredictor()
        self.quality_predictor = QualityPredictor()
        
    async def predictive_optimization(self):
        """äºˆæ¸¬çš„æœ€é©åŒ–ã®å®Ÿè¡Œ"""
        
        # æ¬¡é€±ã®ä½¿ç”¨é‡äºˆæ¸¬
        predicted_usage = await self.usage_predictor.predict_weekly_usage()
        
        # æœ€é©Agenté…ç½®ã®è¨ˆç®—
        optimal_config = await self.calculate_optimal_agent_distribution(
            predicted_usage
        )
        
        # å‹•çš„ãƒªãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°
        await self.rebalance_agent_pool(optimal_config)
        
    async def continuous_learning(self):
        """ç¶™ç¶šå­¦ç¿’ã«ã‚ˆã‚‹æ”¹å–„"""
        
        # éå»å®Ÿç¸¾ã®åˆ†æ
        historical_data = await self.collect_historical_metrics()
        
        # ãƒ¢ãƒ‡ãƒ«ç²¾åº¦ã®æ”¹å–„
        await self.retrain_prediction_models(historical_data)
        
        # æœ€é©åŒ–ãƒ«ãƒ¼ãƒ«ã®æ›´æ–°
        await self.update_optimization_rules()
```

## ã¾ã¨ã‚

### Techsfreeã®å¤šAgent Tokenæœ€é©åŒ–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ä¾¡å€¤

âœ… **å¹³å‡52%ã®ã‚³ã‚¹ãƒˆå‰Šæ¸›**ï¼ˆå®Ÿæ¸¬å€¤ï¼‰  
âœ… **å“è³ªå‘ä¸Šã¨åŠ¹ç‡åŒ–ã®ä¸¡ç«‹**  
âœ… **å®Œå…¨ãªéšœå®³åˆ†é›¢ã«ã‚ˆã‚‹é«˜å¯ç”¨æ€§**  
âœ… **æŸ”è»Ÿãªæ‹¡å¼µæ€§ã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³**  
âœ… **ä¼æ¥­ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ã¸ã®å®Œå…¨å¯¾å¿œ**

### å°å…¥æ¨å¥¨ãƒ•ã‚§ãƒ¼ã‚º

1. **Phase 1**: å˜ä¸€å°‚é–€Agentã§ã®åŠ¹æœæ¤œè¨¼ï¼ˆ1ãƒ¶æœˆï¼‰
2. **Phase 2**: 3-Agentæ§‹æˆã§ã®éƒ¨åˆ†æœ€é©åŒ–ï¼ˆ3ãƒ¶æœˆï¼‰  
3. **Phase 3**: å…¨ç¤¾å±•é–‹ã¨é«˜åº¦ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆ6ãƒ¶æœˆï¼‰

å¼Šç¤¾ã§ã¯ã€ãŠå®¢æ§˜ã®æ¥­å‹™ç‰¹æ€§ã¨äºˆç®—ã«å¿œã˜ã¦ã€æœ€é©ãªå¤šAgentè¨­è¨ˆã‚’ã”ææ¡ˆã„ãŸã—ã¾ã™ã€‚AIé‹ç”¨ã‚³ã‚¹ãƒˆã®åŠ‡çš„å‰Šæ¸›ã‚’ãŠè€ƒãˆã§ã—ãŸã‚‰ã€ãœã²ãŠæ°—è»½ã«ã”ç›¸è«‡ãã ã•ã„ã€‚

---
**About Techsfree**  
Techsfreeã¯ã€ä¼æ¥­ã®AIå°å…¥ã«ãŠã‘ã‚‹ã€Œã‚³ã‚¹ãƒˆåŠ¹ç‡æ€§ã€ã¨ã€Œæ¥­å‹™å“è³ªå‘ä¸Šã€ã®ä¸¡ç«‹ã‚’å®Ÿç¾ã™ã‚‹æŠ€è¡“ã‚³ãƒ³ã‚µãƒ«ãƒ†ã‚£ãƒ³ã‚°ä¼šç¤¾ã§ã™ã€‚å¤šAgent Tokenæœ€é©åŒ–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ãŠã„ã¦ã€å›½å†…æœ€å¤§ã®å°å…¥å®Ÿç¸¾ã¨åŠ¹æœæ¸¬å®šãƒ‡ãƒ¼ã‚¿ã‚’æœ‰ã—ã¦ã„ã¾ã™ã€‚